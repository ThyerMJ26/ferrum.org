language ferrum/0.1



let ParserStep = Rec ( P ->
    { [ ["parseToken", TokenTag, Str]       , Token         -> P ]
    | [ ["tryParseToken", TokenTag, Str]    , (Maybe Token) -> P ]
    | [ ["peekNextToken"]                   , (Maybe Token) -> P ]
    | [ ["takeNextToken"]                   , (Maybe Token) -> P ]
    | [ ["done", ExprLoc],  [] ]
    } );


let ParserK : { Type -> Type } = 
    A -> { A -> ParserStep };
let ParserA : { Type -> Type } = 
    A -> { K @ (ParserK A) -> ParserStep };

-- let ParserHandler = -> error "TODO";

let ParserStepper = { (List Token) -> ParserStep -> ExprLoc };

let parserStepper : ParserStepper = 
    tokens0 -> steps0 -> 
    loop1 ( [tokens: List Token, steps: ParserStep] ->
        match steps
        [ [ ["parseToken", tag, val], k ] |=>
            match tokens
            [ [] |=> error ["parser failed", "expected", [tag, val], "but no tokens left"]
            , [ tok1@[ttag, tval, _] ,, tokens2 ] |=>
                if ((tag==ttag) && (val==tval))
                [ -> 
                    let step2 = k tok1;
                    continue [tokens2, step2]
                , ->
                    error ["parser failed", "expected", [tag, val], "but got", tok1]
                ]
              ]
            
        , [ ["tryParseToken", tag, val], k ] |=>
            match tokens
            [ [] |=> 
                let step2 = k [];
                continue [tokens, step2]
            , [ tok1@[ttag, tval, _] ,, tokens2 ] |=>
                if ((tag==ttag) && (val==tval))
                [ -> 
                    let step2 = k [tok1];
                    continue [tokens2, step2]
                , ->
                    let step2 = k [];
                    continue [tokens, step2]
                ]
            ]

        , [ ["peekNextToken"], k ] |=>
            match tokens
            [ [] |=> 
                let step2 = k [];
                continue [tokens, step2]
            , [ tok1 ,, tokens2 ] |=>
                -- let _ = debug ["PEEK", tok1];
                let step2 = k [tok1];
                continue [tokens, step2]
            ]

        , [ ["takeNextToken"], k ] |=>
            match tokens
            [ [] |=> 
                let step2 = k [];
                continue [tokens, step2]
            , [ tok1,,tokens2 ] |=>
                -- let _ = debug ["TAKE", tok1];
                let step2 = k [tok1];
                continue [tokens2, step2]
            ]

        , [ ["done", result], [] ] |=>    
            break result   
        
        ]
    ) [tokens0, steps0];

let hParseToken : { [TokenTag, Str] -> { Token -> ParserStep } -> [ ["parseToken", TokenTag, Str], Token -> ParserStep ] } = 
    ( [ tag, val] ) -> 
    ( k : { Token -> ParserStep } ) ->
    [ ["parseToken", tag, val], k ];

let hTryParseToken : { [TokenTag, Str] -> { (Maybe Token) -> ParserStep } -> [ ["tryParseToken", TokenTag, Str], (Maybe Token) -> ParserStep ] } = 
    ( [tag, val] ) -> 
    ( k : { (Maybe Token) -> ParserStep } ) ->
    [ ["tryParseToken", tag, val], k ];

let hPeekNextToken : { { (Maybe Token) -> ParserStep } -> [ ["peekNextToken"], (Maybe Token) -> ParserStep ] } = 
    ( k : { (Maybe Token) -> ParserStep } ) ->
    [ ["peekNextToken"], k ];

let hTakeNextToken : { { (Maybe Token) -> ParserStep } -> [ ["takeNextToken"], (Maybe Token) -> ParserStep ] } = 
    ( k : { (Maybe Token) -> ParserStep } ) ->
    [ ["takeNextToken"], k ];

let hDone : { ExprLoc -> [ ["done", ExprLoc], [] ] } = 
    ( expr : ExprLoc ) ->
    [ ["done", expr], [] ];

let Parser = List Token;
let parserMk : { (List Token) -> Parser } =
    tokens -> tokens;

let parserDo : { (ParserA ExprLoc) -> Parser -> ExprLoc } =
    action -> tokens ->
    parserStepper tokens <|
    action <| result ->
    hDone result;


-- let hLoop1 = stepLoop ParserStep;
let hLoop2 = stepLoop2 ParserStep;
let hFunc0 = stepFunc0 ParserStep;
let hFunc1 = stepFunc1 ParserStep;
let hFunc2 = stepFunc2 ParserStep;
let hFunc3 = stepFunc3 ParserStep;
let hFunc4 = stepFunc4 ParserStep;
let hFunc5 = stepFunc5 ParserStep;
