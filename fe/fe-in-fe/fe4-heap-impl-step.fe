language ferrum/0.1

let heapStyle : HeapStyle = "Step";

let Heap1 = 
    {[ "Heap"
    ,  (List Indirect)
    ]};

let heapEmpty1 = ["Heap", []];
let heapMk1 : { [] -> Heap1 } = -> ["Heap", []];


let HeapStep = Rec ( HS -> 
    { [ ["hGet",    Addr],                Indirect     -> HS ]
    | [ ["hSet",    Addr, Indirect],      []           -> HS ]
    | [ ["hNew",    NodeCommon, Node],    Addr         -> HS ]
    | [ ["skip"],                         []           -> HS ]
    | [ ["done", Any],                    []                 ]
    } );

let heapStepper1 : { Heap1 -> HeapStep -> [Heap1, Any] } =
    ["Heap", heap0] -> step0 ->
    loop1 ( [heap: List Indirect, step: HeapStep] ->
        match step
        [ [ ["hGet", addr], k ] |=>
            let indirect = listIndex heap addr;
            continue [ heap, k indirect ]
        , [ ["hSet", addr, indirect], k ] |=>
            let heap2 = listUpdate heap addr indirect;
            continue [ heap2, k [] ]
        , [ ["hNew", nc, node], k ] |=>
            let addr = length heap;
            let indirect = [addr, [], nc, node];
            let heap2 = append heap [indirect];
            continue [ heap2, k addr ]
        , [ ["skip"], k ] |=>
            continue [ heap, k [] ] 
        , [ ["done", result], [] ] |=>
            break [ ["Heap", heap], result]
        ] 
    ) [heap0, step0];


let Heap2 = 
    {[ "Heap"
    ,  (Array Indirect)
    ]};

let heapEmpty2 : Heap2 = [ "Heap", mkArrayList Indirect [] ];
-- let heapEmpty2 : Heap2 = [ "Heap", mkArrayFastAccessSlowCopy Indirect [] ];

-- let heapMk2 : { [] -> Heap2 } = -> [ "Heap", mkArrayList Indirect [] ];
-- let heapMk2 : { [] -> Heap2 } = -> [ "Heap", mkArrayFastAccessSlowCopy Indirect [] ];
let heapMk2 : { [] -> Heap2 } = -> [ "Heap", mkArrayFastAccessNoCopy Indirect [] ];

let heapStepper2 : { Heap2 -> HeapStep -> [Heap2, Any] } =
    ["Heap", heap0] -> step0 ->
    loop1 ( [heap: Array Indirect, step: HeapStep] ->
        match step
        [ [ ["hGet", addr], k ] |=>
            -- let indirect = listIndex heap addr;
            let [heap2, indirect] = heap ["get", addr];
            continue [ heap2, k indirect ]
        , [ ["hSet", addr, indirect], k ] |=>
            -- let heap2 = listUpdate heap addr indirect;
            let [heap2,[]] = heap ["set",addr,indirect];
            continue [ heap2, k [] ]
        , [ ["hNew", nc, node], k ] |=>
            -- let addr = length heap;
            let [heap2,addr] = heap ["length"];
            let indirect = [addr, [], nc, node];
            -- let heap2 = append heap [indirect];
            let [heap3,[]] = heap2 ["extend",[indirect]];
            continue [ heap3, k addr ]
        -- , [ ["hClone"], k ] |=>
        --     let [heap2, length] = heap ["length"];
        --     let [heap3, arrayCloned] = heap2 ["slice", 0, length];
        --     let heapCloned: Heap2 = ["Heap", arrayCloned];
        --     continue [ heap3, k heapCloned ]
        , [ ["skip"], k ] |=>
            continue [ heap, k [] ] 
        , [ ["done", result], [] ] |=>
            break [ ["Heap", heap], result]
        ] 
    ) [heap0, step0];



-- let Heap = Heap1;
-- let heapEmpty = heapEmpty1;
-- let heapMk = heapMk1;
-- let heapStepper = heapStepper1;

let Heap = Heap2;
let heapEmpty = heapEmpty2;
let heapMk = heapMk2;
let heapStepper = heapStepper2;



let HeapSnapshot = { [] -> Heap };

let snapshotHeap : { Heap -> [Heap, HeapSnapshot] } =
    ["Heap", heapArray] -> 
    let [heapArray2, arraySnapshot] = heapArray ["snapshot"];
    [ ["Heap", heapArray2], -> ["Heap", arraySnapshot[]]];

-- let HeapK : { Type -> Type } = 
--     T -> 
--     { { T -> HeapStep} -> HeapStep };

let HeapK : { Type -> Type } = 
    A -> { A -> HeapStep };
let HeapAction : { Type -> Type } = 
    A -> { K @ (HeapK A) -> HeapStep };
let HeapA = HeapAction;




let heapWhile = stepWhile HeapStep;
let heapMap = stepMap HeapStep;
-- let heapLoop1 = stepLoop1 HeapStep;
let heapLoop2 = stepLoop2 HeapStep;
-- let heapLoop = heapLoop2;


let heapGet : { Addr -> (HeapK Indirect) -> HeapStep } =
    addr -> returnK ->
    [ ["hGet", addr], returnK ];

let heapSet : { Addr -> Indirect -> (HeapK Nil) -> HeapStep } =
    addr -> indirect -> returnK ->
    [ ["hSet", addr, indirect], returnK ];

let heapNewNode : { NcNode -> (HeapK Addr) -> HeapStep } =
    [nc, node] -> returnK ->
    [ ["hNew", nc, node], returnK ];

let heapNew : { [] -> (HeapK Addr) -> HeapStep } =
    [] ->
    -- let ncNode = [ [0, "Term", "Weak", "None", []], ["HHole"] ];
    let ncNode = [ [0, "Weak", "None", []], ["HHole"] ];
    heapNewNode ncNode;

let heapSkip : { (HeapK Nil) -> HeapStep } =
    k ->
    [ ["skip"], k ];

-- let heapClone : { (HeapK Heap2) -> HeapStep } =
--     k ->
--     [ ["hClone"], k ];

let heapDone : { Any -> HeapStep } =
    result ->
    [ ["done", result], [] ];



let heapDo : { { Result : Type } -> (HeapA Result) -> Heap -> [Heap, Result] } =
    (Result : Type) -> (action : HeapA Result) -> (heap : Heap) -> 

    let [heap2, result1] = heapStepper heap <|
        action <| result ->
        heapDone result;

    let result2 = justTrustMeCast Any Result result1;

    [heap2, result2];


let heapToList : { Heap -> [Heap, (List Indirect)] } =
    [_, h0] ->
    let [h1, hLength] = h0 ["length"];
    let pos0 : Int = 0;
    let inds0 : List Indirect = [];
    let [h4, _, inds2] =
        while [h1, pos0, inds0] <|
        [h2, pos1, inds1] ->
        guardLt [pos1, hLength] <| _ =>
        let [h3, ind] = h2 ["get", pos1];
        [h3, pos1 + 1, [ind ,, inds1]];
    let result = [["Heap", h4], reverse inds2];
    result;


let heapMatch       = stepMatch       HeapStep;
let heapMatchGuard  = stepMatchGuard  HeapStep;
let heapMatchFail   = stepMatchFail   HeapStep;
let heapMatchOk     = stepMatchOk     HeapStep;

let heapFunc0       = stepFunc0       HeapStep;
let heapFunc1       = stepFunc1       HeapStep;
let heapFunc2       = stepFunc2       HeapStep;
let heapFunc3       = stepFunc3       HeapStep;
let heapFunc4       = stepFunc4       HeapStep;
let heapFunc5       = stepFunc5       HeapStep;
