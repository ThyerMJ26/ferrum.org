language ferrum/test/0.1

-- language ferrum_test_0

-- these are fe4 tests, copied and ported from the fe3 tests in types.test.fe

[ 

  [ ["name", "let-pat"]
  , ["language", "ferrum/0.1"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      let [a,b] = [1,2];
      let c = a + b;
  """
  ]
  , ["expectValue", "c", "3"]
  , ["expectType",  "c", "Int"]
  ]

, [ ["name", "lambda-pat"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      let Pos = { [Int, Int] };
      let Input = List Str;
      let  f = [pos : Pos, input : Input] ->
          let [row, col] = pos;
          [row, col + 1];
      let pos1 = [1, 2];
      let pos2 = f [pos1, ["7","8","9"]];
  """
  ]
  , ["expectTerm", "pos2", "[1,3]"]
  , ["expectValue", "pos2", "[1,3]"]
  , ["expectType",  "pos2", "{ [Int, Int] }"]
  ]


, [ ["name", "flip-cons"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      
        -- flip = \(f: F@(\(_:Void) -> \(_:Void) -> Any)) 
        --     -> \(x: X@(Domain (Codomain F)))
        --     -> \(y: Y@(Domain F))
        --      -- : (applyT (applyT F Y) X)
        --     -> f y x;
        
      let flip2 = (f : F @ { Void -> Void -> Any }) 
            -> (x : X @ (Domain (Codomain F)))
            -> (y : Y @ (Domain F))
             -- : (applyT (applyT F Y) X)
            -> f y x;
        
        -- cons : \(_:A@Any) -> \(_:B@Any) -> Pair A B 
        --      = \(a:A@Any)-> \(b:B@Any) -> (a,b);

      let cons2 : { A @ Any -> B @ Any -> [A ,, B] } 
             = (a : A @ Any) -> (b : B @ Any) -> [a ,, b];
      
      let flipCons = flip2 cons2;
  """
  ]
  , ["expectType", "flip2", "{ F @ { Void -> Void -> Any } -> X @ (Domain (Codomain F)) -> Y @ (Domain F) -> { F Y X } }"]
  , ["expectType", "cons2", "{ A @ Any -> B @ Any -> { [A ,, B] } }"]
  , ["expectType", "flipCons", "{ X @ Any -> Y @ Any -> { [Y ,, X] } }"]
  , ["expectType", "flip2 cons2", "{ X @ Any -> Y @ Any -> { [Y ,, X] } }"]
  ]


, [ ["name", "twice-inc"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      let twice = (f : F @ { (Domain F) -> (Domain F) }) -> (z : Domain F) -> f (f z);
      let inc = (x : Int) -> x + 1;
      let five = twice inc 3;
      -- twice2 is a universally polymorphic version
      -- it can only take a polymorphic id function ( { A @ Any -> A }, but not { Int -> Int } ), so cannot increment
      let twice2 : { F @ { A @ Any -> A } -> Z @ (Domain F) -> F { F Z }} = 
        (f : F @ { A @ Any -> A }) -> (z : Z @ (Domain F)) -> f (f z);
      let id : { X @ Any -> X } = (x : X @ Any) -> x;
      let three = twice2 id 3;
  """
  ]
  , ["expectValue", "five", "5"]
  , ["expectType", "five", "Int"]
  , ["expectValue", "three", "3"]
  , ["expectType", "three", "Int"]
  , ["typeCheckFail", "twice2 inc"] -- TODO this isn't curently being checked by runtest.ts
  ]



, [ ["name", "foldl"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
          let foldl : { F @ { Void -> Void -> (Domain F) } -> (Domain F) -> (List (Domain (Codomain F))) -> (Domain F) } =
              (f : F @ { Void -> Void -> (Domain F) }) ->
              (z : (Domain F)) ->
              (x : List (Domain (Codomain F))) ->
              [z, x] |> 
              loop1 <| [z : Domain F, x : List (Domain (Codomain F))] ->
              ifNil x
              [ -> break z
              , [hx ,, tx] -> continue [f z hx, tx]
              ];
          let six = foldl ((a : Int) -> (b : Int) -> a + b) 0 [1,2,3];
  """
  ]
  , ["expectValue", "six", "6"]
  , ["expectType", "six", "Int"]
  ]

, [ ["name", "foldl1"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
        let foldl1 : { F1 @ { Void -> (Domain F1) -> (Domain F1) } -> X1 @ { [(Domain F1) ,, (List (Domain F1))] } -> (Domain F1) } =
                (f : F1 @ { Void -> (Domain F1) -> (Domain F1) }) ->
                ( [x1 ,, xs] : { [(Domain F1) ,, (List (Domain F1))] }) ->
                [x1, xs] |>
                loop1 <| [z : Domain F1, x : List (Domain F1)] ->
                ifNil x
                [ -> break z
                , [x1 ,, xs] -> continue [f z x1, xs]
                ];
        let six = foldl1 ((a : Int) -> (b : Int) -> a + b) [1,2,3];
  """
  ]
  , ["expectValue", "six", "6"]
  , ["expectType", "six", "Int"]
  ]





-- TODO implement foldl1 using foldl, type-system currently too dumb to spot (Dom F) and (Dom (Rng F)) are the same
, [ ["name", "foldl1d"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
        let foldl : { F @ { Void -> Void -> (Domain F) } -> (Domain F) -> (List (Domain (Codomain F))) -> (Domain F) } =
            (f : F @ { Void -> Void -> (Domain F) }) ->
            (z : (Domain F)) ->
            (x : List (Domain (Codomain F))) ->
            [z, x] |> 
            loop1 <| [z : Domain F, x : List (Domain (Codomain F))] ->
            ifNil x
            [ -> break z
            , [hx ,, tx] -> continue [f z hx, tx]
            ];

        -- Using (Domain F1) in-place of the Void, creates an odd type-error involving intersection types,
        -- but using (Domain F1) here might be the key to being able to call the commented out foldl function.
        -- Possibly the same improvements to typeHd/typeTl regarding self-types, need to be applied to typeDom/typeCod
        let foldl1 : { F1 @ { Void -> (Domain F1) -> (Domain F1) } -> { [(Domain F1) ,, (List (Domain F1))] } -> (Domain F1) } =
                (f : F1 @ { Void -> (Domain F1) -> (Domain F1) }) ->
                ( [x1 ,, xs] : { [(Domain F1) ,, (List (Domain F1))] }) ->
                -- foldl f x1 xs;
                [x1, xs] |>
                loop1 <| [z : Domain F1, x : List (Domain F1)] ->
                ifNil x
                [ -> break z
                , [x1 ,, xs] -> continue [f z x1, xs]
                ];
        let six = foldl1 ((a : Int) -> (b : Int) -> a + b) [1,2,3];
  """
  ]
  , ["expectValue", "six", "6"]
  , ["expectType", "six", "Int"]
  ]








-- , [ ["name", "implode-reverse"]
--   , ["expr", 
--   """
--      let {
--        -- foldl : \F@(\void=> \void=> Domain F)=> \Z@(Domain F)=> \X@(List (Domain (applyT F Z)))=> Domain F
--        foldl : \F@(\void=> \void=> Domain F)=> \Z@(Domain F)=> \X@(List (Domain (Codomain F)))=> Domain F
--              = \(f:F@(\void=> \void=> Domain F))
--             -> \(z:Z@(Domain F))
--             -- -> \(x:X@(List (Domain (applyT F Z))))
--             -> \(x:X@(List (Domain (Codomain F))))
--             : Domain F
--             ->
--            loop1 (\(z: Domain F, x: List (Elem X))->
--                case x of {
--                    ()      -> break z;
--                    (x1,xs) -> continue (f z x1, xs);
--                })
--            (z, x);
-- 
--           flip = \(f: F@(\Void=> \Void=> Any)) 
--               -> \(x: X@(Domain (Codomain F)))
--               -> \(y: Y@(Domain F))
--                -- : (Codomain (Codomain F))
--               -> f y x;
--           
--           cons : \A@Any=> \B@Any=> Pair A B 
--                = \(a:A@Any)-> \(b:B@Any) -> (a,b);
--           
-- 
-- 
--         reverse : \L@(List Any)=> List (Elem L) 
--                 = \(l:L@(List Any)) ->
--                   foldl 
--                   (flip cons: \(List (Elem L))=> \(Elem L)=> List (Elem L))
--                   ((): List (Elem L))
--                   (l: List (Elem L));
-- 
-- 
--        implode = \(strList: List Str)-> foldl (\(a:Str)-> \(b:Str)-> a^b) ("": Str) strList;
--  
--      } in
--      implode (reverse (["3","2","1"]: List Str))
--   """
--   ]
--   , ["expected_value", "\"123\""]
--   , ["expected_type", "Str"]
--   ]



-- , [ ["name", "append"]
--   , ["expr", 
--   """
--         let {
--           -- foldl : \(F@(\Void=> \Void=> Domain F))=> \Z@(Domain F)=> \X@(List (Domain (applyT F Z)))=> Domain F
--           foldl : \(F@(\Void=> \Void=> Domain F))=> \Z@(Domain F)=> \X@(List (Domain (Codomain F)))=> Domain F
--                 = \(f:F@(\Void=> \Void=> Domain F))
--                -> \(z:Z@(Domain F))
--                -- -> \(x:X@(List (Domain (applyT F Z))))
--                -> \(x:X@(List (Domain (Codomain F))))
--                : Domain F
--                ->
--               loop1 (\(z: (Domain F), x: List (Domain (Codomain F))) -> 
--                     case x of {
--                       [] -> break z;
--                       (x1, xs) -> continue (f z x1, xs);
--                     }
--               )
--               (z, x);
-- 
--           flip = \(f: F@(\Void=> \Void=> Any)) 
--               -> \(x: X@(Domain (Codomain F)))
--               -> \(y: Y@(Domain F))
--                -- : (Codomain (Codomain F))
--               -> f y x;
--           
--           cons : \A@Any=> \B@Any=> Pair A B 
--                = \(a:A@Any)-> \(b:B@Any) -> (a,b);
--           
--           reverse : \L@(List Any)=> List (Elem L) 
--                   = \(l:L@(List Any)) 
--                   : List (Elem L) 
--                   ->
--                     foldl 
--                     (flip (cons: \(Elem L)=> \(List (Elem L))=> List (Elem L)))
--                     -- (flip cons)
--                     -- ((): List (Elem L))
--                     ()
--                     l;
-- 
--           append  : \X@(List (Elem X))=> \(List (Elem X))=> List (Elem X)
--                   = \(xs:X@(List (Any))) 
--                  -> \(ys:Y@(List (Elem X)))
--                   : List (Elem X)
--                  ->
--                   -- foldl (flip (cons: \(Elem X)=> \(List (Elem X))=> List (Elem X))) ys (reverse xs);
--                   foldl (flip cons: \(List (Elem X))=> \(Elem X)=> List (Elem X)) ys (reverse xs);
--                   -- foldl (flip cons) ys (reverse xs);
--         } in
--         append ([1,2,3] : List Int) ([7,8,9] : List Int)
-- 
--   """
--   ]
--   , ["expected_value", "[1,2,3,7,8,9]"]
--   , ["expected_type", "List Int"]
--   ]


-- , [ ["name", "map"]
--   , ["expr", 
--   """
--       let {
--       foldl : \F@(\Void=> \Void=> Domain F)=> \Z@(Domain F)=> \X@(List (Domain (Codomain F)))=> Domain F
--             = \(f: F@(\Void=> \Void=> Domain F))
--            -> \(z:Z@(Domain F))
--            -> \(x:X@(List (Domain (Codomain F))))
--            : Domain F
--            ->
--           loop1 (\(z: Domain F, x: List (Domain (Codomain F))) ->
--                 case x of { 
--                   [] -> break z;
--                   (x1, xs) -> continue (f z x1, xs);
--                 })
--           (z, x);
--       
--       
--       flip = \(f: F@(\Void=> \Void=> Any)) 
--           -> \(x: X@(Domain (Codomain F)))
--           -> \(y: Y@(Domain F))
--           -> f y x;
--       
--       cons : \A@Any=> \B@Any=> Pair A B 
--            = \(a:A@Any)-> \(b:B@Any) -> (a,b);
--       
--       
--       reverse : \L@(List Any)=> List (Elem L) 
--               = \(l: L@(List Any)) 
--                   : List (Elem L) 
--               ->
--                 foldl 
--                 (flip cons: \(List (Elem L))=> \(Elem L)=>List (Elem L))
--                 ()
--                 (l: List (Elem L));
--       
--       implode = \(strList: List Str) -> foldl (\(a:Str)-> \(b:Str)-> a^b) ("") strList;
--       
--       append  -- : \X@(List (Elem X))=> \(List (Elem X))=> List (Elem X)
--               = \(xs:X@(List (Any))) 
--              -> \(ys:Y@(List (Elem X)) )
--               : List (Elem X)
--              ->
--               -- foldl (flip cons) ys (reverse xs);
--               foldl (flip cons: \(List (Elem X))=> \(Elem X)=>List (Elem X)) ys (reverse xs);
--       
--       map1 = \(f:F@(\Void=>Any))-> \(xs:X@(List (Domain F)))->
--         loop1 (\((xs,ys):Pair (List (Elem X)) (List (Codomain F)))-> 
--                       case xs of {
--                         [] -> break ys;
--                         (xs1, xss) -> continue (xss, (f xs1, ys));
--                       }
--         ) (reverse (xs:List (Elem X)), ());
-- 
--       map = \(f: F@(\void=>Any))-> \(x: X@(List (Domain F))) ->
--         loop1 (\(x: List (Elem X), y: List (applyT F (Elem X)))->
--           case x of {
--               ()      -> break y;
--               (x1,xs) -> continue (xs, (f x1, y));
--           }
--         ) (reverse x, ());
-- 
-- 
--       } in map (\(x:Int)->x*x) [1,2,3,4,5]
--       
--   """
--   ]
--   , ["expected_value", "[1,4,9,16,25]"]
--   , ["expected_type", "List Int"]
--   ]



, [ ["name", "concat"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      let reverse = (l : L1 @ (List (Elem L1))) ->
          [[], l] |>
          loop1 <| [result : List (Elem L1), l : List (Elem L1)] ->
          ifNil l
          [ -> break result
          , [l1 ,, ls] -> continue [[l1 ,, result], ls]
          ];

      let append = (x : X @ (List (Elem X))) -> (y : (List (Elem X))) -> 
          [y, reverse x] |>
          loop1 <| [result : List (Elem X), l : List (Elem X)] ->
          ifNil l
          [ -> break result
          , [l1 ,, ls] -> continue [[l1 ,, result], ls]
          ];

      let concat : { L2 @ (List (List (Elem (Elem L2)))) -> (List (Elem (Elem L2))) } =
          (l : L2 @ (List (List (Elem (Elem L2))))) ->
          [[], reverse l] |>
          loop1 <| [result : List (Elem (Elem L2)), l : List (Elem L2)] ->
          ifNil l
          [ -> break result
          , [l1 ,, ls] -> continue [append l1 result, ls]
          ];
      let nums = concat ([[1,2,3],[4,5,6],[7,8,9]] : List (List Int));
      
  """
  ]
  , ["expectValue", "nums", "[1,2,3,4,5,6,7,8,9]"]
  , ["expectType", "nums", "{(List Int)}"]
  ]


, [ ["name", "loop"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
      let lookup2 : { Any -> KVS @ (List { [Any, Any] }) -> (Hd (Tl (Elem KVS))) } =
          key -> (kvs : KVS @ List { [Any, Any] }) ->
          kvs |>
          -- (kvs : List (Elem KVS)) |>
          loop1 <| (kvs : List (Elem KVS)) ->
          ifNil kvs
          [ -> error ["lookup failed", key]
          -- , [ [k, v] ,, kvs2 ] -> -- TODO work out why this form has stopped working 
          , [ kv ,, kvs2 ] ->
                let [k, v] = kv; -- TODO why do we need the "[k,v]" pattern here ? it would be better placed in the lambda-pattern above ? 
                if (key == k)
                [ -> break v
                , -> continue kvs2
                ]
          ];
      let two = -> lookup2 "banana" ([["apple",1],["banana",2],["carrot",3]] : List { [Str, Int] }) : Int;
      
  """
  ]
  , ["expectValue", "two []", "2"]
  , ["expectType", "two []", "Int"]
  ]


, [ ["name", "foldr"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
        let reverse = (l : L1 @ (List Any)) ->
          loop1 ( [result : List (Elem L1), l : List (Elem L1)] ->
            ifNil l
            [ -> break result
            , [l1 ,, ls] -> continue [[l1 ,, result], ls]
            ]
          ) [[], l];

        let foldr : { F @ { Void -> Void -> (Domain (Codomain F)) } -> Z @ (Domain (Codomain F)) -> X @ (List (Domain F)) -> (Domain (Codomain F)) } =
              (f : F @ { Void -> Void -> (Domain (Codomain F)) }) ->
              (z : Z @ (Domain (Codomain F))) ->
              (x : X @ (List (Domain F))) ->
              loop1 ( [z : Domain (Codomain F), x : List (Elem X)] ->
                  ifNil x
                  [ -> break z
                  , [x1 ,, xs] -> continue [f x1 z, xs]
                  ]
              ) [z, reverse x];
        let t1 = -> foldr ( (a : Int) -> (b : List Int) -> [a ,, b]: List Int) ([]: List Int) [1,2,3];

  """
  ]
  , ["expectValue", "t1[]", "[1,2,3]"]
  , ["expectType", "t1[]", "{(List Int)}"]
  ]


-- , [ ["name", "iok"]
--   , ["language", "ferrum/0.1"]
--   , ["type_check", "bidir"]
--   , ["decls", 
-- 
--       -- TODO check this is running in the right order (don't we need a reverse?)
--       -- mapK = \(f: F@(\(Domain F)=> \(IOK (Domain (Domain (Codomain F))))=>applyT (Domain (Codomain F)) (Domain F) ))
--       -- mapK = \(f: F@(\(void)=> \(IOK (Domain (Domain (Codomain F))))=>applyT (Domain (Codomain F)) (Domain F) ))
--       -- mapK = \(f: F@(\(void)=> \(IOK (Any))=>applyT (Domain (Codomain F)) (Domain F) ))
--       -- \A=> \ioWorld=> Any
--       -- mapK = \(f: F@(\(void)=> \(\(Domain F)=> \ioWorld=> Any)=>applyT (Domain (Codomain F)) (Domain F) ))
--       -- mapK = \(f: F@(\(void)=> \(\(void)=> \ioWorld=> Any)=>Codomain (Domain (Codomain F)) ))
-- 
--       --     : applyT (Domain (Codomain F)) (Domain F)
--       --     : Codomain (Domain (Codomain F))
-- 
--   """
--       let IOK = (A : type) -> { A -> ioWorld -> Any };
--       let IOK0 =  { ioWorld -> [] };
--       let iokDon e: IOK0 = (world1 : ioWorld) -> [];
--       let iokPrint = (contents : Str) -> (k : IOK {[]}) -> (world1 : ioWorld) ->
--           let [result, world2] = ioPrint contents world1; } in 
--           k result world2;
-- 
--       -- mapK = \(f: F@(\(void)=> \(\(Domain (Domain (Codomain F)))=> \ioWorld=> Any)=> \ioWorld=> Any ))
--       mapK = \(f: F@(\(void)=> \(\Any=> \ioWorld=> Any)=> \ioWorld=> Any ))
--           -> \(x: List (Domain F))
--           -> \(k: IOK (List (Domain (Domain (Codomain F)))))
--            : \ioWorld=>Any
--           ->
--           loop1 (\(x: List (Domain F), ks: IOK (List (Domain (Domain (Codomain F)))))->
--               case x of {
--                   ()      -> break (ks []);
--                   (x1,xs) -> continue (xs, \(ys: (List (Domain (Domain (Codomain F)))))-> f x1 \(y1: Domain (Domain (Codomain F)))-> ks (y1,ys) );
--               }
--           ) (x, k);
--       
--          printNumList = 
--            mapK (\(n:Int)-> \(k: IOK Str)->
--              iokPrint ("Num: "^n) $ \_->
--              k (n^"."^n)
--            ) [1,2,3] $ \(result: List Str)->
--            iokPrint (""^result) $ \_->
--            \(world: ioWorld)->result;
-- 
--      } in ioRun printNumList 
-- 
--   """
--   ]
--   , ["expected_value", "[\"1.1\",\"2.2\",\"3.3\"]"]
-- --  , ("expected_type", "List Str")
--   , ["expected_type", "Any"]
--   ]

, [ ["name", "Fix-const"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
       let t1 = 7 : Fix <| (a : Type) ->Int;
    """
    ]
  , ["expectValue", "t1", "7"]
  , ["expectType", "t1", "Int"]
  ]


, [ ["name", "Fix-list"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
       let t1 = [7,8,9] : Fix <| A -> { [] | [Int ,, A] };
    """
    ]
  , ["expectValue", "t1", "[7,8,9]"]
  -- , ["expectType", "t1", "(Rec {A -> { [] | { [Int ,, A] } }})"]
  , ["expectType", "t1", "(Fix (A -> { [] | { [Int ,, A] } }))"]
  ]


, [ ["name", "tree"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
          let strCat = jsStrCat;

          let Tree = Fix <| Tree ->
              let Leaf = { ["Leaf", Int] };
              let Branch = { ["Branch", Tree, Tree] };
              { Leaf | Branch };

          let tree0_a = ["Leaf", 1];
          let tree0_b = ["Branch", ["Leaf", 1], ["Leaf", 2]];

          let tree1 = ["Branch", ["Branch", ["Leaf", 1], ["Leaf", 2]], ["Leaf", 3]];
          let tree2 = ["Branch", ["Branch", ["Leaf", 1], ["Leaf", 2]], ["Branch", ["Leaf", 3], ["Leaf", 4]]];

          let Maybe = (A : Type) -> { [] | [A] };
          let headOrElse : { A @ (Maybe Any) -> { -> (Hd A) } -> (Hd A) } =
            (aMb : A @ Maybe Any) -> orElse ->
            ifNil aMb
            [ orElse
            , [a] -> a
            ];

          let showTree = fix <| (st : { Tree -> Str }) -> (t : Tree) -> 
               let leafMb = t |> ["Leaf", n] |=> show n;
               ifNil leafMb
               [ ->
                 let branchMb = t |> ["Branch", a, b] |=> jsStrCat ["< ", st a," ", st b," >"];
                 ifNil branchMb
                 [ -> error "pat-mat failure"
                 , [branch] -> branch
                 ]
               , [leaf] -> leaf
               ];

          let showTree2 = fix <| (st : { Tree -> Str }) -> (t : Tree) -> 
               headOrElse ( t |> ["Leaf", n] |=> show n ) <| ->
               headOrElse ( t |> ["Branch", a, b] |=> jsStrCat ["< ", st a," ", st b," >"] ) <| ->
               error "pat-mat failure";

          let showTree3 = fix <| (st : { Tree -> Str }) -> (t : Tree) -> 
               headOrElse ( t |> ["Leaf", n] |=> show n ) <| ->
               headOrElse ( t |> ["Branch", a, ["Branch", b, c]] |=> jsStrCat ["<< ", st a, " ", st b, " ", st c, " >>"] ) <| ->
               headOrElse ( t |> ["Branch", a, b] |=> jsStrCat ["< ", st a," ", st b," >"] ) <| ->
               error "pat-mat failure";

          let t0a = showTree tree0_a;
          let t0b = showTree tree0_b;
          let t1 = showTree tree1;
          let t2 = showTree2 tree1;
          let t3 = showTree2 tree2;
          let t4 = showTree3 tree2;
    """
    ]
  , ["expectValue", "t0a", "\"1\""]
  , ["expectValue", "t0b", "\"< 1 2 >\""]
  , ["expectValue", "t1", "\"< < 1 2 > 3 >\""]
  , ["expectValue", "t2", "\"< < 1 2 > 3 >\""]
  , ["expectValue", "t3", "\"< < 1 2 > < 3 4 > >\""]
  , ["expectValue", "t4", "\"<< < 1 2 > 3 4 >>\""]
  ]


-- , [ ["name", "tree2"]
--   , ["type_check", "bidir"]
--   , ["expr", 
--     """
--        let { 
--            Tree = Fix (\Tree->Union
--                [ Variant "Leaf" Int 
--                , Variant "Branch" (Pair Tree Tree)
--                ]);
-- 
--            t1 = ("Branch", ("Branch", (("Leaf", 1), ("Leaf", 2))), ("Leaf", 3));
--            t2 = ("Branch", ("Branch", (("Leaf", 1), ("Leaf", 2))), ("Branch", (("Leaf", 3), ("Leaf", 4))));
-- 
--            showTree = fix \(st: \Tree=>Str)-> \(t:Tree)-> case t of
--                { ("Branch", a, ("Branch", b, c)) -> "<< "^ st a ^" "^ st b ^" "^ st c ^" >>"
--                ; ("Branch", a, b) -> "< "^ st a ^" "^ st b ^" >"
--                ; ("Leaf", n)      -> ""^n
--                ;};
--        } in
--        showTree t2
--     """
--     ]
--   , ["expected_value", "\"<< < 1 2 > 3 4 >>\""]
--   , ["expected_type", "Str"]
--   ]


-- , [ ["name", "tuple-list"]
--   , ["language", "ferrum/0.1"]
--   , ["type_check", "bidir"]
--   , ["decls", 
--     """
--        let {
-- 
--         reverse = \(l: L1@(List Any))->
--           loop1 (\(result: List (Elem L1), l: List (Elem L1))->
--             case l of {
--               () -> break result;
--               (l1, ls) -> continue ((l1,result), ls);
--             }
--           ) ([], l);
-- 
-- 
--          Tuple = \(x:List type)->
--            loop1 (\(xs: List type, result: type)->
--                case xs of {
--                    [] -> break result;
--                    (x1,xs2) -> continue (xs2, Pair x1 result);
--                }
--            ) (reverse x, nil);
--   
--          ParseTreeC = Fix \(PTC: type)-> Tuple [Str, List PTC, List Int, Int];
--          -- ParseTreeC = Tuple [Str, List Str, List Int, Int];
--   
--          ptcPt = \([name, pts, toks, loc]: ParseTreeC) -> (name, pts, toks);
-- 
--          init_val = ["a", [], [], 7];
--        } in
--        ptcPt init_val
--     """
--     ]
--   , ["expected_value", "[\"a\"]"]
--   , ["expected_type", ""]
--   ]


, [ ["name", "self-ref-func-type"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
         -- F = \(A@Void)=> \A=> A;
         -- F = Fix (\(T:type) -> \(Domain T)=> \(Domain T)=>(Domain T));
         -- F = Fix (\(T:type) -> \(Void)=> \(Domain T)=>(Domain T));
         -- F = Fix { {f:F} -> Void -> dom f -> dom f};
         -- F = Domain ( \(T@( \void => \(Domain T) => Domain T )) => Any );

        let F = SelfT <| T -> { Void -> (Domain T) -> (Domain T) };
        -- let F = Self <| (t : T @ Any) -> { Void -> (Domain T) -> (Domain T) };
        
        let f = (a : Int) -> (b : Int) -> a + b;
        -- let g = (f : F1 @ F) -> (x : Domain F1): Domain F1 -> f x x;
        let g = (f : F1 @ F) -> (x : Domain F1) -> f x x;
        let t1 = g f 7;
    """
    ]
  , ["expectValue", "t1", "14"]
  , ["expectType", "t1", "Int"]
  ]


-- , [ ["name", "cons-cons-list"]
--   , ["language", "ferrum/0.1"]
--   , ["type_check", "bidir"]
--   , ["decls", 
--     """
--           Cons = \A@Any=> \B@Any=> Pair A B;
--           cons : Cons
--                = \(a:A@Any)-> \(b:B@Any) -> (a,b);
-- 
--           ConsList = \A@Any=> \B@(List Any)=> List (unionT A (Elem B));
--           consList : ConsList
--                    = \(a:A@Any)-> \(b:B@(List Any)) -> (a,b);
--       
--        } in
--        (cons: ConsList) 1 [2]
--     """
--     ]
-- --  , ("type_check", "bidir")
--   , ["expected_value", "[1,2]"]
--   , ["expected_type", "List Int"]
--   ]



, [ ["name", "continuation"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 

  """

       -- convert = 
       --     \(num: Int)-> 
       --     \(k: \Pair Int Str=>Str)->  
       --     k (num, ""^ num ^"*"^ num ^"="^ (num*num));
       --     
       -- call = 
       --     \(f: \Int=> \(\(Pair Int Str)=>Str)=> Str)-> 
       --     \(input: Int)-> 
       --     \(k: \(Pair Int Str)=>Str)-> 
       --     f input k;

      let strCat = jsStrCat;
      let convert = 
           (num : Int) -> 
           (k : { [Int, Str] -> Str }) ->  
           k [num, strCat [show num, "*", show num, "=", show (num*num)]];
           
      let call = 
           (f : F @ { Void -> { Any -> Str } -> Str }) -> 
           (input : (Domain F)) -> 
           (k : { (Domain (Domain (Codomain F))) -> Str }) -> 
           f input k;

      let angleK = (result @ [n, s] : { [Int, Str] }) -> strCat ["<", show n, ", ", s, ">"];
      
      let t1 = -> call convert 7 angleK;

  """
  ]
  , ["expectValue", "t1[]", "\"<7, 7*7=49>\""]
  , ["expectType", "t1[]", "Str"]
  ]

, [ ["name", "swap"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 

  """
      -- TODO this first version of swap used to work in fe3
      -- TODO ? do we want it to work again ?
      -- TODO currently it results in a type of { [B, A] }, the variables have escaped

      -- let swap = [a : A @ Any, b : B @ Any] -> [b : B, a : A];

      -- The type syntax
      --   "{ T @ [Any, Any] } -> ..." 
      --  should be written 
      --   "T @ { [Any, Any] } -> ..."
      -- TODO Enforce this during parsing, rather than letting the later code trip over it.
      -- TODO ? Change the AST to include the "@" type-name in ELambda node, so as not to need a separate EAs node ?
      -- TODO ?   Or include the "@" type-name within the EType node ?
      -- TODO ?   Or maybe a separate ETypeAs node, only permitted at the root of a lambda (and let?) pattern ?
      -- let swap : { T @ [Any, Any] -> [(Hd (Tl T)), (Hd T)] } =
      --     ([a, b] : { T @ [Any, Any] }) -> [b, a];

      let swap : { T @ [Any, Any] -> [(Hd (Tl T)), (Hd T)] } =
          ([a, b] : T @ { [Any, Any] }) -> [b, a];

      let t1 = swap [1,"one": Str];

  """
  ]
  , ["expectValue", "t1", "[\"one\",1]"]
  , ["expectType", "t1", "{ [Str, Int] }"]
  ]

, [ ["name", "type-error-foldl"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
        let foldl :  { F @ { Void -> Void -> (Domain F) } -> Z @ (Domain F) -> X @ (List (Domain { F Z })) -> Z } =
              (f : F @ { Void -> Void -> (Domain F) }) ->
              (z : Z @ Domain F) ->
              (x : X @ List (Domain { F Z })) ->
              loop1 ( [z : Z, x : List (Elem X)] ->
                  ifNil x
                  [ -> break z
                  , [x1 ,, xs] -> continue [f z x1, xs] -- this shouldn't type-check, (f z x1) doesn't neccessarily return something of type Z
                  ]
              )
              [z, x];

        let flipConsList : { B @ (List Any) -> A @ Any -> (List { A | (Elem B) }) } = 
              (b : B @ List Any) -> (a : A @ Any) -> [a ,, b];
          
        let reverse : { L @ (List Any) -> (List (Elem L)) } = 
              (l : L @ List Any) -> 
              foldl flipConsList ([]) l;
              -- foldl (flipConsList: \(List (Elem L))=> \Elem L=>List (Elem L)) [] l; -- this shouldn't type-check without the type annotation on [], hmmm

        let t1 = reverse [1,2,3];
  """
  ]
  , ["expected_type_errors", 1]
  , ["expectValue", "t1", "[3,2,1]"]
  ]


, [ ["name", "type-error-flip-cons"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
        let F = { B @ (List Any) -> A @ Any -> B };
        let flipConsList : { B @ (List Any) -> A @ Any -> (List { A | (Elem B) }) } =
              (b : B @ List Any) -> (a : A @ Any) -> [a ,, b];
          
        let t1 = flipConsList : F;
  """
  ]
  , ["expected_type_errors", 1]
  , ["expectType", "t1", "{ B @ {(List Any)} -> A @ Any -> B }"]
  ]



-- , [ ["name", "intersect-variant"]
--   , ["expr", 
--   """
--         let {
-- 
--             reverse: \L@(List Any)=>List (Elem L) = \_->error "reverse";
-- 
--             Pos = Pair Int Int;
--             Range = Pair Pos Pos;
--             Loc = Pair Str Range;
--             
--             Atomic = 
--               Union
--                 [ Variant "AStr" Str
--                 , Variant "AInt" Int
--                 ];
-- 
--             Token = 
--               Pair Pos (Pair Pos (
--                 Union
--                   [ Variant "LexAtomic" Atomic
--                   , Variant "LexId" Str
--                   , Variant "LexKeyId" Str
--                   , Variant "LexOp" Str
--                   , Variant "LexKeyOp" Str
--                   , Variant "LexSep" Str
--                   , Variant "LexEOF" niltype-error-flip-cons
--                   ]));
-- 
--             nullToken = [(0,0),(0,0),("LexEOF"]);
-- 
--             ParseTree = 
--               Fix (\(PT:type)->
--                 Union 
--                   [ Variant "token" Token
--                   , Variant "rule" (Pair Str (List PT))
--                   ]);
--             
--             ParseTreeToken = intersectT ParseTree (Pair (singleT "token") Any);
--             ParseTreeRule  = intersectT ParseTree (Pair (singleT "rule" ) Any);
--             
--             
--             RuleResultOk = Variant "ok" (Pair ParseTree (Pair (List Token) Token));
--             RuleResultFail = Variant "fail" (Pair Token Token);
--             RuleResult = Union [RuleResultOk, RuleResultFail];
--             
--             Rule = \(List Token)=> RuleResult;
--             RulesTable = Fix (\(RT:type)-> List (Pair Str (\RT=> \(List Token)=> RuleResult)));
--             Rule1 = \RulesTable=> \(List Token)=> RuleResult;
--             
--             
--             -- nop = \(rt: RulesTable)-> \(tokens: List Token)-> (("fail", hd tokens): RuleResult);
--             
--             furthest = \(a@((rowA,colA),_,__): Token)-> \(b@((rowB,colB),___,____): Token): Token-> 
--               if rowA > rowB then a else
--               if rowB > rowA then b else
--               if colA > colB then a else
--               if colB > colA then b else
--               a;
--               
--             
--             def = \(name: Str, rule: Rule1)-> (name: Str, rule: Rule1);
--             
--             seq = \(rules:Pair Rule1 (List Rule1))-> \(rt: RulesTable)-> \(tokens: List Token): RuleResult->
--                 loop1 (\((rule,rules): Pair Rule1 (List Rule1), tokens: List Token, pts: List ParseTree, far: Token)->
--                   case rule rt tokens of {
--                       ("ok", pt, tokens2, far2) -> 
--                           case rules of {
--                             [] -> break (("ok", ("rule", "seq", reverse ((pt,pts): List ParseTree)): ParseTreeRule, tokens2, furthest far far2): RuleResult);
--                             (rules1,ruless) -> continue ((rules1,ruless), tokens2, (pt,pts), furthest far far2);
--                           };
--                       ("fail", tok, far2) -> break ("fail", tok, furthest far far2);
--                   }
--                 ) (rules,tokens,[],nullToken);
--             
--         } in
--         seq
--   """
--   ]
--   , ["expected_type_errors", 0]
--   ]


-- , [ ["name", "pair-match-variant"]
--   , ["expr", 
--     """
--        let {
--            Pos = Pair Int Int;
--            Range = Pair Pos Pos;
--            Loc = Pair Str Range;
--            
--            Atomic = 
--              Union
--                [ Variant "AStr" Str
--                , Variant "AInt" Int
--                ];
--            
--            Token = 
--              Pair Pos (Pair Pos (
--                Union
--                  [ Variant "LexAtomic" Atomic
--                  , Variant "LexId" Str
--                  , Variant "LexKeyId" Str
--                  , Variant "LexOp" Str
--                  , Variant "LexKeyOp" Str
--                  , Variant "LexSep" Str
--                  , Variant "LexEOF" nil
--                  ]));
--            
--            TokenNoPos = Tl (Tl Token);
-- 
--            parse_tok : \TokenNoPos=> \(Pair Token (List Token))=> List Token
--                      = \(expected_tok@(expected_tag,expected_value): TokenNoPos)
--                     -> \(input@(token@(start,finish,tok@(tag,value)),input2): List Token) ->
--              -- trace ("parse_tok",expected_tok) $
--              if (tag==expected_tag) && (value==expected_value) 
--              then input2
--              else error ("unexpected token",token,"expected",expected_tok);
-- 
--        } in
--        1
--     """
--     ]
--   , ["expected_value", "1"]
--   , ["expected_type", "Int"]
--   ]


-- -- This test works with the fe4/tree-types implementation but not the fe4/graph-types implementation.
-- -- It's possible it will never work with both at the same time.
-- -- This test doesn't need to type-check in order for the fe-in-fe code to type-check.
-- -- It can be revisited when everything else is more mature and tree-types are ready to be jettisoned.
-- , [ ["name", "codec-pair"]
--   , ["language", "ferrum/0.1"]
--   , ["type_check", "bidir"]
--   , ["decls", 
--     """
--         let Codec = SelfT <| A -> { [Str -> Any, { (Hd A) Str } -> Str] };
--         -- let Codec = Self <| (a : A @ { [Type, Type] }) -> { [Str -> Any, { (hd a) Str } -> Str] };
--         -- let Codec = Self <| (a : A @ { [Str -> Any, Void -> Str] }) -> { [Str -> Any, { (Single (hd a)) Str } -> Str] };
--         -- let Codec = Self <| (a : A @ { [Str -> Any, Void -> Str] }) -> { [Str -> Any, { { _ : (hd a) } Str } -> Str] };
--         -- This version is possibly the best way to define the type.
--         --    It makes it possible to take the non-dependent tail of the tuple, 
--         --    this is useful when computing non-dependent context types.
--         --    Checking the tail against { Void -> Str } and then checking the whole self-dependent tuple makes sense.
--         --    Checking the tail against { Any -> Str } or { (Hd V1) Str -> Str } is harder to make work.
--         -- let Codec = Self <| (a : A @ { [Str -> Any, Void -> Str] }) -> { [Str -> Any, { (Hd A) Str } -> Str] };
--         let codec1 : Codec = [ (a : A @ Any)  -> a         , (a : Str) -> a         ];
--         let codec2 : Codec = [ (a : Str)      -> strOrd a  , (a : Int) -> strChr a  ];
--         let testCodec = 
--             ([encode, decode] : C @ Codec) -> 
--             (a : Str) ->
--             decode (encode a) == a;
--         let t1 = ->
--           [ testCodec codec1 "A"
--           , testCodec codec2 "A"
--           , testCodec codec1 "Apple"
--           , testCodec codec2 "Apple"
--           ];
--     """
--     ]
--   , ["expectValue", "t1[]", "[true,true,true,false]"]
--   , ["expectType", "t1[]", "{ [Bool, Bool, Bool, Bool] }"]
--   ]
-- 



-- , [ ["name", "sum-product-type"]
--   , ["language", "ferrum/0.1"]
--   , ["type_check", "bidir"]
--   , ["decls", 
--     """
--           SumProd = Union
--             [ Variant "Int" Int
--             , Variant "Str" Str
--             ];
--           -- a@(ax,ay): SumProd = ("Int", 7): SumProd;
--           -- a@(ax,ay): Pair Any Any = ("Int", 7): SumProd;
--           (a@(ax,ay): SumProd): Pair Any Any = ("Int", 7): SumProd;
--           -- a@(ax,ay) = ("Int", 7): SumProd;
--           -- a: SumProd = ("Int", 7);
--           b: SumProd = ("Str", "seven");
--         } in
--         (a,b)
--     """
--     ]
--   , ["expected_value", "[[\"Int\",7], [\"Str\", \"seven\"]]"]
--   -- , ("expected_type", "")
--   -- , ("type_check", "simple")
--   ]


, [ ["name", "type-error-sum-product"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
        let SumProd = 
            { ["Int", Int] 
            | ["Str", Str]
            };
        let a @ [ax, ay] : SumProd = ["Int", "seven"];
        let b: SumProd = ["Str", 7];
    """
    ]
  , ["expected_type_errors", 2]
  ]


-- , [ ["name", "sum-product-func"]
--   , ["expr",
--     """
--         let {
--           SumProd = Union
--             [ Variant "Int" Int
--             , Variant "Str" Str
--             ];
--           f = \(sp@(x,y): SumProd)->y;
--           a = f ("Int", 7);
--           b = f ("Str", "seven");
--         } in
--         (a,b)
--     """
--     ]
--   , ["expected_value", "[7,\"seven\"]"]
--   -- , ("expected_type", "")
--   -- , ("type_check", "simple")
--   ]


, [ ["name", "type-error-sum-product-func"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
        let SumProd = { ["Int", Int] | ["Str", Str] };
        let f = (sp @ [x,y] : SumProd) -> y;
        let a = f ["Int", "seven"];
        let b = f ["Str", 7];
    """
    ]
  , ["expected_type_errors", 2]
  ]


-- , [ ["name", "dup"]
--   , ["expr",
--     """
--         let {
--           dup = \x->(x,x);
--         } in
--         dup 7
--     """
--     ]
--   , ["expected_value", "(7,7)"]
--   -- , ("type_check", "simple")
--   ]




-- , [ ["name", "unzip"]
--   , ["expr",
--     """
--         let {
-- 
--             reverse = \(l: L@(List Any))->
--               loop1 (\(result: List (Elem L), l: List (Elem L))->
--                 case l of {
--                   () -> break result;
--                   (l1, ls) -> continue ((l1,result), ls);
--                 }
--               ) ([], l);
-- 
-- 
--             unzip : \L@(List (Pair Any Any)) => Pair (List (Hd (Elem L))) (List (Tl (Elem L)))
--                   = \(l:L@(List (Pair Any Any))) ->
--                   loop1 (\(a: List (Hd (Elem L)), b: List (Tl (Elem L)), l: (List (Elem L))) ->
--                     case l of {
--                       []           -> break (a,b);
--                       ((a1,b1),ls) -> continue ((a1,a),(b1,b),ls);
--                     }
--                   ) ([], [], reverse l);
-- 
--             -- reverse = \(l: L1@(List Any))->
--             --   loop1 (\(result: List (Elem L1), l: List (Elem L1))->
--             --     case l of {
--             --       () -> break result;
--             --       (l1, ls) -> continue ((l1,result), ls);
--             --     }
--             --   ) ([], l);
-- 
--             -- unzip : \L2@(List (Pair Any Any)) => Pair (List (Hd (Elem L2))) (List (Tl (Elem L2)))
--             --       = \(l:L2@(List (Pair Any Any))) ->
--             --       loop1 (\(a: List (Hd (Elem L2)), b: List (Tl (Elem L2)), l: (List (Elem L2))) ->
--             --         case l of {
--             --           []           -> break (a,b);
--             --           ((a1,b1),ls) -> continue ((a1,a),(b1,b),ls);
--             --         }
--             --       ) ([], [], reverse l);
-- 
-- 
--         } in 
--         unzip [(1,2),(3,4),(5,6)]
--     """
--     ]
--   , ["expected_value", "[[1,3,5] ,, [2,4,6]]"]
--   -- , ("type_check", "simple")
--   ]


-- , [ ["name", "tuple-list-pat"]
--   , ["expr",
--     """
--         let {
--           [a, b, c]: List Int = [1,2,3];
--         } in
--         a+b+c
--     """
--     ]
--   , ["expected_value", "6"]
--   , ["type_check", "bidir"]
--   ]


-- , [ ["name", "func-type-infer"]
--   , ["expr",
--     """
--         let {
--           f: \Int=>Int = \x-> x*x;
--         } in
--         f 7
--     """
--     ]
--   , ["expected_value", "49"]
--   , ["type_check", "bidir"]
--   ]






]

